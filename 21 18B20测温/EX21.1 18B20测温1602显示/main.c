/***************************************************************************************************    
工程名称：	18b20_1602
功能描述：	18B20传感器测温，1602显示温度值。
硬件连接：  用1位杜邦线将J11_7与J17_1820连接，将1602液晶接口对应插接到P4接口。
维护记录：  2011-8-22
***************************************************************************************************/
#include"reg51.h"
#include"intrins.h"     //_nop_();延时函数用
#define uchar unsigned char
#define uint unsigned int

sbit DQ=P2^7;    //温度控制口


sbit rs=P2^5;    //命令/数据选择
sbit rw=P2^4;    //读写口
sbit  e=P2^3;    //锁存控制

uchar data dis0[16]={'T','h','e',' ','t','e','m','p',' ','n','o','w',' ','i','s',':',};//LCD第1行
uchar data dis[10]={' ',' ',' ',0x00,0x00,0x00,'.',0x00,0xeb,'C'};                     //LCD第2行
//**************************************************************************************************
//精确延时函数(使用12M晶振，延时T=2*t+5个指令周期,t为char型,改为int型,会加大误差）
//**************************************************************************************************
void delay(uint t)
{
 while(--t);
}
//**************************************************************************************************
//延时函数
//**************************************************************************************************
delay1(uint time)         //int型数据为16位,所以最大值为65535            
 {
  uint  i,j;             //定义变量i,j,用于循环语句 
  for(i=0;i<time;i++)    //for循环,循环50*time次
     for(j=0;j<120;j++); //for循环,循环50次
 }
//**************************************************************************************************
//向LCD写一命令
//**************************************************************************************************
wcode(uchar t)
{
  rs=0;           // 写的是命令
  rw=0;           // 写状态
  e=1;            //使能
  P0=t;           //写入命令 
  delay1(20);      //等待写入,如果时间太短，会导致液晶无法显示
  e=0;            //数据的锁定
}
//**************************************************************************************************
//向LCD写一数据
//**************************************************************************************************
wdata(uchar t)
{
  rs=1;          // 写的是数据
  rw=0;          // 写状态
  e=1;           //使能
  P0=t;          //写入数据
  delay1(20);     //等待写入,如果时间太短，会导致液晶无法显示
  e=0;           //数据的锁定
}
//**************************************************************************************************
//LCD显示
//**************************************************************************************************
show()
{
  uchar i;
  wcode(0x80);          //设置第一行显示地址
  for(i=0;i<16;i++)     //循环16次，写完1行
    {
      wdata(dis0[i]);   //写入该行数据
    }

  wcode(0xc6);          //设置第一行显示地址
  for(i=0;i<10;i++)     //循环16次，写完1行
    {
      wdata(dis[i]);   //写入该行数据
    }
}
//**************************************************************************************************
//LCD 初始化
//**************************************************************************************************
InitLCD()
   {  		 
   wcode(0x01);	  //清屏
   wcode(0x06);   //输入方式控制,增量光标不移位
   wcode(0x0e);   //显示开关控制
   wcode(0x38);   //功能设定:设置16x2显示，5x7显示,8位数据接口     	
   } 
//**************************************************************************************************
//传感器初始化
//**************************************************************************************************
init_18b20()
{
        uchar flag;
        DQ=1;
        delay(10);  //延时
        DQ=0;
        delay(500); //*延时，要求精度，要求大于480us*
        DQ=1;
        delay(200); //*延时，要求精度，要求大于15us*
        flag=DQ;    //DQ管脚送出60-240us的0脉冲,以示初始化成功
        delay(10);  //延时
}
//**************************************************************************************************
//写一个字节函数
//**************************************************************************************************
write_byte(uchar t)
{
 uchar i;
 for(i=0;i<8;i++)   //循环8次写入1字节
  {
    DQ=0;           //数据线置低
    delay(10);      //延时
    DQ=t&0x01;      //发送1位数据,最低位开始
    delay(50);      //*延时，要求精度*
    DQ=1;           //数据线置高
    t=t>>1;         //右移1位
  }
}
//**************************************************************************************************
//读一个字节函数
//**************************************************************************************************
uchar read_byte()
{
 uchar i,value=0;;
 for(i=0;i<8;i++)   //循环8次读取1字节
  {
    value=value>>1; //右移1位
    DQ=0;           //数据线置低
    delay(10);      //延时
    DQ=1;           //数据线置高
    delay(10);      //延时
    if(DQ==1)value=value|0x80;//判断接收的1位数据是否为1
    delay(50);      //*延时，要求精度*
  }
 return(value);
}
//**************************************************************************************************
//数据处理子函数
//**************************************************************************************************
chuli(uint temperature)
{
 float t;
 if(temperature&0x8000)         //判断是否为负数
   {
     temperature=~temperature+1;//取反加1
     dis[3]=0xb0;               //显示负号
   }
 else
   {
     dis[3]=0x2b;               //显示正号 
   }
 t=temperature*0.0625+0.05;     //计算出温度值，百分位四舍五入

 temperature=t*10;              //本实验显示到小数点后1位,所以乘10，以便分离得到十分位

 dis[7]=temperature%10+0x30;    //除10取余得温度十分位，1602只识别ASCII码，+0x30目的就是把16进制转ASCII
 dis[4]=temperature/100+0x30;   //除100取整得温度十位
 dis[5]=temperature%100/10+0x30;//除100取余得十位和个位，然后除10取整得温度个位
}
//**************************************************************************************************
//温度采集函数
//**************************************************************************************************
uint get_temp()
{
    uint dat;
    uchar wenl,wenh;
    init_18b20();         //复位
    write_byte(0xcc);     //不进行编号匹配
    write_byte(0x44);     //进行温度转换
    init_18b20();         //复位   
    write_byte(0xcc);     //不进行编号匹配
    write_byte(0xbe);     //发读命令
    wenl=read_byte();     //温度低八位
    wenh=read_byte();     //温度高八位
    dat=(wenh<<8)+wenl;   //数据高低8位合并
    return(dat);          //返回测量结果
}
//**************************************************************************************************
//主函数
//**************************************************************************************************
main()
{
  uint temp;
  InitLCD();             //液晶初始化

  while(1)               //死循环
  {  
    temp=get_temp();     //获取温度值
    chuli(temp);         //数据处理 
    show();              //显示温度值
    delay1(500);         //延时
  }
}