C51 COMPILER V7.06   MAIN                                                                  07/28/2012 09:54:58 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          /***************************************************************************************************    
   2          工程名称：      IIC
   3          功能描述：      每按下一次复位键或重新给系统上电，发光二极管表示的数据加1，实现记录开机次数。
   4          硬件连接：  用8位杜邦线将J8与J13连接，2位杜邦线分别将J11_7与J17_SDA、J11_6与J17_SCL连接
   5          维护记录：  2011-8-22
   6          ***************************************************************************************************/
   7          #include "reg51.h"      //包含头文件
   8          #include"intrins.h"     //_nop_();延时函数用
   9          
  10          sbit sda=P2^7;          //数据线
  11          sbit scl=P2^6;          //时钟线
  12          
  13          #define uchar unsigned char
  14          #define uint  unsigned int
  15          
  16          //**************************************************************************************************
  17          //延时
  18          //**************************************************************************************************
  19          delay(uint time)              //int型数据为16位,所以最大值为65535            
  20           {
  21   1        uint  i,j;                  //定义变量i,j,用于循环语句 
  22   1        for(i=0;i<time;i++)         //for循环,循环50*time次
  23   1           for(j=0;j<50;j++);       //for循环,循环50次
  24   1       }
  25          //**************************************************************************************************
  26          //启动(SCL为高，SDA由高变为低是一个开始条件)
  27          //**************************************************************************************************
  28          void start()  
  29          {       
  30   1              sda=1;    //数据线置高,
  31   1              _nop_();  //延时
  32   1              scl=1;    //时钟线置高
  33   1              _nop_();  //延时
  34   1              sda=0;    //数据线置低,由高变低
  35   1              _nop_();  //延时
  36   1              scl=0;    //时钟线置低,准备发送或接收数据,总线进入忙状态(I2C总线在空闲状态时，SDA与SCL均被置高)
  37   1              _nop_();  //延时
  38   1      }
  39          //**************************************************************************************************
  40          //停止（SCL为高，SDA由低变为高是一个结束条件）
  41          //**************************************************************************************************
  42          void stop()   
  43          {
  44   1              sda=0;                   //数据线置低
  45   1              _nop_();                 //延时
  46   1              scl=1;                   //时钟线置高
  47   1              _nop_();                 //延时
  48   1              sda=1;                   //数据线置高，由低变高
  49   1              _nop_();                 //延时
  50   1      }
  51          //**************************************************************************************************
  52          //检测应答(所有的地址和数据字都是以8bit,在第9个时钟周期，从器件发出"0"信号来作为收到一个字的应答信号)
  53          //**************************************************************************************************
  54          void checkACK()                   //主器件检测从器件是否返回应答
  55          {
C51 COMPILER V7.06   MAIN                                                                  07/28/2012 09:54:58 PAGE 2   

  56   1              scl=1;                        //时钟线置高
  57   1              _nop_();                      //延时
  58   1              while(sda==1);                //等待第9个时钟周期器件发出的响应信号"0"
  59   1              scl=0;                        //时钟线置低
  60   1              _nop_();                      //延时
  61   1      }
  62          //**************************************************************************************************
  63          //发送应答(发送方为主器件，接收方为从器件，控制器作为从器件接收完1数据时，发送应答信号
  64          //**************************************************************************************************
  65          void sendACK(bit ACK)                   
  66          {
  67   1          if(ACK)sda=1;            //如果i位为1则发送1,即发送"非应答信号"
  68   1            else sda=0;            //如果i位为0则发送0,即发送"应答信号"       
  69   1          scl=1;                   //时钟线置高,给一个脉冲
  70   1              _nop_();                 //延时
  71   1              scl=0;                   //时钟线置低
  72   1              _nop_();                 //延时
  73   1      }
  74          //**************************************************************************************************
  75          //写一字节
  76          //**************************************************************************************************
  77          void send_byte(uchar date)       //写一个8位字
  78          {
  79   1              uchar i,temp;                //定义局部变量
  80   1              temp=date;                   //待发8位数据赋予temp
  81   1              for(i=0;i<8;i++)             //循环8次，每次写入1位，从最高位开始发送
  82   1              {
  83   2              if(temp&0x80)sda=1;      //如果temp最高位为1则发送1
  84   2                else sda=0;            //如果temp最高位为0则发送0
  85   2                  _nop_();                 //延时
  86   2                      scl=1;                   //给一个脉冲，发送sda当前这位数据
  87   2                      _nop_();                 //延时,需大于4us(参考数据手册时序图) 
  88   2                      _nop_();              
  89   2                      _nop_();                 
  90   2                      _nop_();                 
  91   2                      _nop_();                
  92   2                      scl=0;                   //时钟线置低,准备下一脉冲
  93   2                  _nop_();                 //延时,需大于4.7us(参考数据手册时序图) 
  94   2                      _nop_();              
  95   2                      _nop_();                 
  96   2                      _nop_();                 
  97   2                      _nop_();  
  98   2                      temp=temp<<1;            //左移1位，准备好下1位待发送的数据
  99   2              }
 100   1              checkACK();                  //查询是否返回应答信号
 101   1      }
 102          //**************************************************************************************************
 103          //读一字节
 104          //**************************************************************************************************
 105          uchar receive_byte()         //读一个8位字
 106          {
 107   1              uchar i,temp;            //定义局部变量
 108   1              sda=1;                   //设置数据线为输入
 109   1              _nop_();                 //延时
 110   1              for(i=0;i<8;i++)         //循环8次，每次读取1位，从最高位开始接收
 111   1              {
 112   2                      scl=1;               //给一脉冲，准备发送1位数据            
 113   2                      _nop_();             //延时,需大于4us(参考数据手册时序图) 
 114   2                      _nop_();              
 115   2                      _nop_();                 
 116   2                      _nop_();                 
 117   2                      _nop_();
C51 COMPILER V7.06   MAIN                                                                  07/28/2012 09:54:58 PAGE 3   

 118   2                      temp=(temp<<1)|sda;  //读取1位数据,放在temp最低位
 119   2                      scl=0;               //准备给下1个脉冲
 120   2                  _nop_();             //延时,需大于4.7us(参考数据手册时序图) 
 121   2                      _nop_();              
 122   2                      _nop_();                 
 123   2                      _nop_();                 
 124   2                      _nop_();       
 125   2              }
 126   1              return temp;             //返回读取的8位数据
 127   1      }
 128          //**************************************************************************************************
 129          //向某I2C器件的某字地址写一字节数据
 130          //**************************************************************************************************
 131          void write_word(uchar device_add,uchar word_add,uchar date)  //写进去一个存储数据
 132          {
 133   1              start();                  //启动
 134   1              send_byte(device_add);    //选择从器件地址,RW位为0，即选择写命令
 135   1              send_byte(word_add);      //写字地址
 136   1              send_byte(date);          //写数据
 137   1              stop();                   //停止        
 138   1      }
 139          //**************************************************************************************************
 140          //向某I2C器件的某字地址读一字节数据
 141          //**************************************************************************************************
 142          uchar read_word(uchar device_add,uchar word_add)   //读出一个存储的数据
 143          {
 144   1              uchar date;
 145   1              start();                 //启动
 146   1              send_byte(device_add);   //选择从器件地址,RW位为0，即选择写命令
 147   1              send_byte(word_add);     //写字地址
 148   1              start();                 //启动
 149   1              send_byte(device_add+1); //选择从器件地址,RW位为1，即选择读命令
 150   1              date=receive_byte();     //读数据
 151   1          sendACK(1);              //发送非应答信号
 152   1              stop();                  //停止
 153   1              return date;             //返回读取结果数据
 154   1      }
 155          //**************************************************************************************************
 156          //主函数
 157          //**************************************************************************************************
 158          void main()
 159          {       
 160   1         uchar temp;                   //定义中间变量
 161   1         temp=read_word(0xa0,0);       //从I2C器件a0的第0个地址读出数据赋予temp
 162   1         write_word(0xa0,0,temp+1);    //向I2C器件a0的第0个地址写temp+1
 163   1         delay(100);                   //延时  
 164   1         while(1)                      //死循环
 165   1          {
 166   2                temp=read_word(0xa0,0);    //从第0个地址读出一个数据
 167   2                delay(100);                //延时
 168   2            P1=~temp;                  //送数据到P1口显示
 169   2              }
 170   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    250    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
C51 COMPILER V7.06   MAIN                                                                  07/28/2012 09:54:58 PAGE 4   

   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
