
/***************************************************************************************************    
工程名称：	4x4key
功能描述：	数码管显示4x4键盘扫描的结果
//     按键    扫描结果 |   按键   扫描结果|  按键   扫描结果 |  按键   扫描结果
//     S1      0XEE     |   S5     0XDE	   |  S9     0XBE     |  S13    0X7E
//     S2      0XED     |   S6     0XDD	   |  S10    0XBD     |  S14    0X7D
//     S3      0XEB     |   S7     0XDB	   |  S11    0XBB     |  S15    0X7B
//     S4      0XE7     |   S8     0XD7	   |  S12    0XB7     |  S16    0X77
硬件连接：  用8位杜邦线将J8与J12连接，用2位杜邦线分别将J11_0与J15_DS1及J11_1与J15_DS2连接，用8位杜邦线将J9与J6连接
维护记录：  2011-8-22
***************************************************************************************************/
#include "reg51.h"       //包含头文件

sbit LE1=P2^0;           //位选573锁存器使能
sbit LE2=P2^1;           //段选573锁存器使能

#define uchar unsigned char
#define uint  unsigned int

uchar keyValue;          //定义扫描结果参数
uchar code dis[16]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,
                   //  0    1    2    3    4    5    6    7    
                     0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71};  //0~F的段码
                   //  8    9    A    B    C    D    E    F  
uchar temp;
//**************************************************************************************************
//延时函数
//**************************************************************************************************
delay(uint time)              //int型数据为16位,所以最大值为65535            
 {
  uint  i,j;                  //定义变量i,j,用于循环语句 
  for(i=0;i<time;i++)         //for循环,循环50*time次
     for(j=0;j<50;j++);       //for循环,循环50次
 }
//**************************************************************************************************
//矩阵键盘扫描函数
//**************************************************************************************************
keyScan()  
{
  uchar scode=0x00;//扫描码
  uchar rcode=0x00;//读回码
  
  P3=0xf0;
  if((P3&0xf0)!=0xf0)                   //判断高4位是否为全1（高4位全1代表没按键按下）

    {
      delay(20);                        //延时去抖动，一般为5ms～10ms（由于机械触点的弹性作用，按键在闭合时不会马上稳定地接通，
	                                    //而在闭合瞬间伴随有一连串的抖动，键抖动会引起一次按键被误读多次）
      P3=0xf0;
      if((P3&0xf0)!=0xf0)               //还能检测到有键盘按下去，按行扫描
        {
		 
          scode=0xfe;                   //置扫描码
          while(scode!=0xef)            //如果没有扫描完，继续扫描
             {
               P3=scode;                //送扫描码
               if((P3&0xf0)!=0xf0)      //检测到了
                 {
                    rcode=P3;           //保存P3口的状态
                    rcode=rcode & 0xf0; //生成返回码高4位
                    scode=scode & 0x0f; //生成返回码低4位
                    keyValue=scode + rcode;//返回键盘编码, 程序跳出键盘扫描函数（程序执行到return语句的时候就返回，他后面的语句都不会执行）。
					return keyValue;					 
                 }
               else
                 {
                   scode=(scode<<1)|0x01;//移位，产生下一行扫描码,顺序：0xfe>>0xfd>>0xfb>>0xf7>>0xef
				   					     //当扫描码为0xef时，判断条件scode!=0xe为假 ，跳出while 循环
                 }
				
             }
           return(0);  //没有检测到返回0
        }
      else             //没有键盘按下去，上一次是一个干扰 
        {
         return(0);    //没有检测到返回0
        }
    }
  else  //没有键盘按下去
    {
     return(0);  //没有检测到返回0
    }
}                           
//**************************************************************************************************
//矩阵键盘扫描结果处理函数
//**************************************************************************************************
uchar keyHandle(uchar value)                     
{
  switch(value)
  {
   case 0xee:{return(0);break;}	   //对应按键S1
   case 0xde:{return(1);break;}	   //对应按键S2	
   case 0xbe:{return(2);break;}	   //对应按键S3	
   case 0x7e:{return(3);break;}	   //对应按键S4	
   case 0xed:{return(4);break;}	   //对应按键S5	
   case 0xdd:{return(5);break;}	   //对应按键S6	
   case 0xbd:{return(6);break;}	   //对应按键S7	
   case 0x7d:{return(7);break;}	   //对应按键S8	
   case 0xeb:{return(8);break;}	   //对应按键S9	
   case 0xdb:{return(9);break;}	   //对应按键S10	
   case 0xbb:{return(10);break;}   //对应按键S11	
   case 0x7b:{return(11);break;}   //对应按键S12
   case 0xe7:{return(12);break;}   //对应按键S13	
   case 0xd7:{return(13);break;}   //对应按键S14	
   case 0xb7:{return(14);break;}   //对应按键S15	
   case 0x77:{return(15);break;}   //对应按键S16
   default:{break;}	
  }
   
}
//**************************************************************************************************
//显示扫描结果函数
//**************************************************************************************************
show()                     
{
     P1=0x00;             //0x00=0000 0000,即选通数码全8位
     LE1=1;               //锁存位
     LE1=0;               //断开锁存,位选573的Q7~Q0仍为0x00
     
     P1=dis[temp];        //0~F的编码
     LE2=1;               //锁存段码
     LE2=0;               //断开锁存,段选573的Q7~Q0仍为dis[temp]   
}

//**************************************************************************************************
//主函数
//**************************************************************************************************
void main()                        //主函数
{
     while(1)                      //进入while死循环
      {
        keyScan();                 //按键扫描
        temp=keyHandle(keyValue);  //处理扫描结果
        show();                    //8位数码管显示按键值                
      }         
}