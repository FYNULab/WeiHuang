
/***************************************************************************************************    
工程名称：	4x4key_timer
功能描述：	定时器中断进行矩阵键盘扫描，数码管显示4x4键盘扫描的结果
//     按键    扫描结果 |   按键   扫描结果|  按键   扫描结果 |  按键   扫描结果
//     S1      0XEE     |   S5     0XDE	   |  S9     0XBE     |  S13    0X7E
//     S2      0XED     |   S6     0XDD	   |  S10    0XBD     |  S14    0X7D
//     S3      0XEB     |   S7     0XDB	   |  S11    0XBB     |  S15    0X7B
//     S4      0XE7     |   S8     0XD7	   |  S12    0XB7     |  S16    0X77
硬件连接：  用8位杜邦线将J8与J12连接，用2位杜邦线分别将J11_0与J15_DS1及J11_1与J15_DS2连接，用8位杜邦线将J9与J6连接
维护记录：  2011-8-22
***************************************************************************************************/
#include "reg51.h"       //包含头文件

sbit LE1=P2^0;           //位选573锁存器使能
sbit LE2=P2^1;           //段选573锁存器使能

#define uchar unsigned char
#define uint  unsigned int

uchar keyValue;          //定义扫描结果参数
uchar code dis[16]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,
                   //  0    1    2    3    4    5    6    7    
                     0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71};  //0~F的段码
                   //  8    9    A    B    C    D    E    F  
uchar temp;
//**************************************************************************************************
//延时函数
//**************************************************************************************************
delay(uint time)              //int型数据为16位,所以最大值为65535            
 {
  uint  i,j;                  //定义变量i,j,用于循环语句 
  for(i=0;i<time;i++)         //for循环,循环50*time次
     for(j=0;j<50;j++);       //for循环,循环50次
 }
//**************************************************************************************************
//矩阵键盘扫描函数
//**************************************************************************************************
keyScan()  
{
  uchar x,y; 
  P3=0xf0;                              //P3赋值0xf0
  if((P3&0xf0)!=0xf0)                   //判断高4位是否为全1（高4位全1代表没按键按下）

    {
      delay(20);                        //延时去抖动，一般为5ms～10ms（由于机械触点的弹性作用，按键在闭合时不会马上稳定地接通，
	                                    //而在闭合瞬间伴随有一连串的抖动，键抖动会引起一次按键被误读多次）
      if((P3&0xf0)!=0xf0)               //如果还能检测到有键盘按下去 
        {
		  x=P3&0xf0;                    //读取P3口数据
          P3=0x0f;                      //反转，P3赋值0x0f             
          y=P3&0x0f;                    //读取P3口数据
          keyValue=x|y;                 //得到扫描结果
        }
    }
}                           
//**************************************************************************************************
//矩阵键盘扫描结果处理函数
//**************************************************************************************************
uchar keyHandle(uchar value)                     
{
  switch(value)
  {
   case 0xee:{return(0);break;}	   //对应按键S1
   case 0xde:{return(1);break;}	   //对应按键S2	
   case 0xbe:{return(2);break;}	   //对应按键S3	
   case 0x7e:{return(3);break;}	   //对应按键S4	
   case 0xed:{return(4);break;}	   //对应按键S5	
   case 0xdd:{return(5);break;}	   //对应按键S6	
   case 0xbd:{return(6);break;}	   //对应按键S7	
   case 0x7d:{return(7);break;}	   //对应按键S8	
   case 0xeb:{return(8);break;}	   //对应按键S9	
   case 0xdb:{return(9);break;}	   //对应按键S10	
   case 0xbb:{return(10);break;}   //对应按键S11	
   case 0x7b:{return(11);break;}   //对应按键S12
   case 0xe7:{return(12);break;}   //对应按键S13	
   case 0xd7:{return(13);break;}   //对应按键S14	
   case 0xb7:{return(14);break;}   //对应按键S15	
   case 0x77:{return(15);break;}   //对应按键S16
   default:{break;}	
  }
   
}
//**************************************************************************************************
//显示扫描结果函数
//**************************************************************************************************
show()                     
{
     P1=0x00;             //0x00=0000 0000,即选通数码全8位
     LE1=1;               //锁存位
     LE1=0;               //断开锁存,位选573的Q7~Q0仍为0x00
     
     P1=dis[temp];        //0~F的编码
     LE2=1;               //锁存段码
     LE2=0;               //断开锁存,段选573的Q7~Q0仍为dis[temp]   
}
//**************************************************************************************************
//定时器中断子程序
//**************************************************************************************************
t0() interrupt 1 using 1
{
  keyScan();                 //按键扫描
  temp=keyHandle(keyValue);  //处理扫描结果
  show();                    //8位数码管显示按键值  
}
//**************************************************************************************************
//定时器中断初始化函数
//**************************************************************************************************
T0_init()        //扫描频率为100HZ,即需定时1/100=00.01s
{
   TMOD=0x01;    //0b00000001  用的是定时器0，工作在方式1（16位寄存器）
                 //要实现定时50ms,(65536-T0)x12/12000000=0.01s得T0=15536即0xd8f0
   TH0=0xd8;     //装定时器初值高8位
   TL0=0xf0;     //装定时器初值低8位
   TR0=1;        //启动定时器0
   ET0=1;        //开定时器0中断
   EA=1;         //开总中断
}
//**************************************************************************************************
//主函数
//**************************************************************************************************
void main()                        //主函数
{
     T0_init();                    //初始化定时器中断
     while(1);                     //进入while死循环            
}